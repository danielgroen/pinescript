//@version=5
strategy('inwCoin Martingale Strategy ( for Bitcoin )', shorttitle='INWCOIN_MARTINGALE_BTC', overlay=true, pyramiding=100, initial_capital=100, commission_type=strategy.commission.percent, commission_value=0.055, slippage=3)



//////////////////////////////////////////////
//      inwCoin   Martingale Strategy ( for Bitcoin )
//      v.1.0
//////////////////////////////////////////////
// v.1.0        : 23/4/2020    : initial version


// color code
color_blue = #0000FF
color_green = #00FF00
color_red = #FF0000
color_yellow = #FFFF00


// SETTING UP VARIABLES //

//trade direction ( Long only because short side is unlimit risk, limit profit)
trade_side = input.string(defval='Long Only', options=['Long Only', 'Short Only'], title='Trade direction')

//data array
price = input(defval=close)

//position size parameter
fixed_position_size_bool = input(false, title='Fixed position size ( Unchecked for percent of initial capital )')
start_position_size = input(5.0, title='Start Position Size ( Fixed or Percent )')

//first entry logic
first_position_logic = input.string(defval='ATR Channel', options=['MACD Line > 0', 'STO RSI cross up', 'ATR Channel'], title='Start Position Logic')

//take profit %
take_profit_percent = input(6.0, title='Take Profit Percent')

//martingale setup
martingale_percent = input(8, title='Start Martingale if price drop with this Percent')
martingale_mult = input(5, title='Martingale Multiplier')

takeProfit = price * take_profit_percent / 100 / syminfo.mintick


///////////////////////////////
// Strategy Logic
///////////////////////////////

// HARD CODE ENTRY LOGICs
// FOR SIMPLICITY OF STRATEGY

////////////////////////////////
// STO RSI
////////////////////////////////
smoothK = 3
smoothD = 3
lengthRSI = 14
lengthStoch = 14
top_line = 80
bottom_line = 20

rsi1 = ta.rsi(price, lengthRSI)
k = ta.sma(ta.stoch(rsi1, rsi1, rsi1, lengthStoch), smoothK)
d = ta.sma(k, smoothD)

stoBuy = k > bottom_line and ta.crossover(d, bottom_line)
stoSell = k < bottom_line and ta.crossunder(d, bottom_line)

////////////////////////////////
//MACD
////////////////////////////////
prd1 = 12
prd2 = 26

AP = ta.ema(price, 2)
Fast = ta.ema(AP, prd1)
Slow = ta.ema(AP, prd2)
ema18 = ta.ema(price, 18)

Bullish = Fast > Slow
Bearish = Fast < Slow

Green = Bullish and AP > Fast
Red = Bearish and AP < Fast
Yellow = Bullish and AP < Fast
Blue = Bearish and AP > Fast

macdBuy = Green and Green[1] == 0
macdSell = Red and Red[1] == 0

////////////////////////////////
// ATR
////////////////////////////////
SC = price
AP1 = 5
AF1 = 0.5



// Slow Trail //
AP2 = 10
AF2 = 2.3
MUL_Trailing = 0.275

SL1 = AF1 * ta.atr(AP1)  // Stop Loss
Trail1 = 0.0
iff_1 = SC > nz(Trail1[1], 0) ? SC - SL1 : SC + SL1
iff_2 = SC < nz(Trail1[1], 0) and SC[1] < nz(Trail1[1], 0) ? math.min(nz(Trail1[1], 0), SC + SL1) : iff_1
Trail1 := SC > nz(Trail1[1], 0) and SC[1] > nz(Trail1[1], 0) ? math.max(nz(Trail1[1], 0), SC - SL1) : iff_2

// ATR2
SL2 = AF2 * ta.atr(AP2)  // Stop Loss
SL3 = MUL_Trailing * AF2 * ta.atr(AP2)  // Stop Loss Top
Trail2 = 0.0
iff_3 = SC > nz(Trail2[1], 0) ? SC - SL2 : SC + SL2
iff_4 = SC < nz(Trail2[1], 0) and SC[1] < nz(Trail2[1], 0) ? math.min(nz(Trail2[1], 0), SC + SL2) : iff_3
Trail2 := SC > nz(Trail2[1], 0) and SC[1] > nz(Trail2[1], 0) ? math.max(nz(Trail2[1], 0), SC - SL2) : iff_4

//ATR3
//Extra trailing for placing stop loss when original trailing is on the top ( by inwCoin )
Trail3 = 0.0
iff_5 = SC > nz(Trail2[1], 0) ? SC + SL3 : SC + SL3
iff_6 = SC < nz(Trail2[1], 0) and SC[1] < nz(Trail2[1], 0) ? math.min(nz(Trail3[1], 0), SC - SL3) : iff_5
Trail3 := SC > nz(Trail2[1], 0) and SC[1] > nz(Trail2[1], 0) ? math.max(nz(Trail3[1], 0), SC + SL3) : iff_6

Hst = Trail1 - Trail2
Sig = ta.ema(Hst, 9)

// Bar color for trade signal //
atrBlue = Hst < 0 and Hst > Sig
atrGreen = Hst > 0 and Hst > Sig
atrGray = Hst > 0 and Hst < Sig
atrRed = Hst < 0 and Hst < Sig

// Signals //
atrBull = ta.barssince(atrGreen) < ta.barssince(atrRed)
atrBear = ta.barssince(atrRed) < ta.barssince(atrGreen)

atrBuy = atrGreen and atrBear[1]
atrSell = atrRed and atrBull[1]


//////////////////////////////////////////////
//    Buy - Sell Signal toggle          //
//////////////////////////////////////////////
Buy = false
Sell = false
if trade_side == 'Long Only'
    if first_position_logic == 'MACD Line > 0'
        Buy := macdBuy
        Buy
    if first_position_logic == 'STO RSI cross up'
        Buy := stoBuy
        Buy
    if first_position_logic == 'ATR Channel'
        Buy := atrBuy
        Buy

if trade_side == 'Short Only'
    if first_position_logic == 'MACD Line < 0'
        Sell := macdSell
        Sell
    if first_position_logic == 'STO RSI cross down'
        Sell := stoSell
        Sell
    if first_position_logic == 'ATR Channel'
        Sell := atrSell
        Sell


pricePercent = 0.0
// Take profit logic
if trade_side == 'Long Only'
    pricePercent := (price - strategy.position_avg_price) * 100 / strategy.position_avg_price

    if pricePercent > take_profit_percent
        Sell := true

if trade_side == 'Short Only'
    pricePercent := (price - strategy.position_avg_price) * 100 / strategy.position_avg_price

    if pricePercent > take_profit_percent
        Buy := true

// double down logic
BuyMore = pricePercent <= martingale_percent * -1
SellMore = pricePercent <= martingale_percent * -1

//////////////////////////////////////////////
//    Position Size calculation         //
//////////////////////////////////////////////
var countMartingale = 0.0  //martingale count

var startUnitSize = 0.0
var unit_size = 0.0
var unit_size_martingale = 0.0

//position size calculation
if fixed_position_size_bool
    unit_size := start_position_size
    unit_size
else
    unit_size := strategy.equity * (start_position_size / 100) / price
    unit_size

startUnitSize := unit_size
unit_size_martingale := startUnitSize * math.pow(martingale_mult, countMartingale)

//extra vars to check account equity/capital
var liquidate_price = 0.0
var current_leverage = 0.0
var current_loss = 0.0
var current_capital = 0.0

current_capital := strategy.initial_capital + strategy.netprofit
current_leverage := current_capital / strategy.equity
liquidate_price := strategy.position_avg_price - strategy.position_avg_price / (current_leverage + 1)



//////////////////////////////////////////////
//    define strategy entry / exit          //
//////////////////////////////////////////////

// LIVEMODE:: ENABLE / DISABLE
enableLiveTest = input.bool(false, title="Enable live mode and stop backtesting", group="Livemode / Backtesting")
curDate = timestamp('2023, 08, 06')
targetDate = input.time(curDate, title="Start live mode from:", group="Livemode / Backtesting")
// LIVEMODE:: END

if enableLiveTest == false or time > targetDate
    if trade_side == 'Long Only'
        if Buy and countMartingale == 0.0 and strategy.equity >= 0
            strategy.entry('Long', strategy.long, qty=unit_size, when=strategy.position_size <= 0)
            countMartingale := 1
            Sell := false

        if BuyMore and countMartingale > 0
            strategy.entry('Long', strategy.long, qty=unit_size_martingale, when=strategy.position_size > 0 and strategy.equity >= 0)
            countMartingale += 1
            Sell := false

        if Sell or strategy.equity <= 0
            strategy.close('Long')
            countMartingale := 0

    if trade_side == 'Short Only'

        if Sell and countMartingale == 0.0 and strategy.equity >= 0
            strategy.entry('Short', strategy.short, qty=unit_size, when=strategy.position_size >= 0)
            countMartingale := 1
            Buy := false

        if SellMore and countMartingale > 0
            strategy.entry('Short', strategy.short, qty=unit_size_martingale, when=strategy.position_size < 0 and strategy.equity >= 0)
            countMartingale += 1
            Buy := false

        if Buy or strategy.equity <= 0
            strategy.close('Short')
            countMartingale := 0

//plot data for debugging 
// plot(strategy.equity, color=color.new(color.orange, 0))
// plot(strategy.position_avg_price, color=color.new(color.white, 0))
//plot(liquidate_price,color=color.red)
//plot(current_leverage)
//plot(current_capital)
// plot(strategy.position_size)
//plot(countMartingale)

